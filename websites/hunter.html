
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Shadow Stalker — Single File</title>
<style>
  :root{--bg:#071018;--panel:#0f2430;--accent:#3ec1a9;--danger:#e25b5b;--muted:#9fb2c7}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg) 0%, #051021 100%);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:#e6eef6;display:flex;align-items:center;justify-content:center}
  #wrap{width:920px;max-width:96vw;margin:22px auto}
  canvas{display:block;width:100%;height:auto;background:transparent;border-radius:12px;box-shadow:0 18px 40px rgba(2,8,12,0.7)}
  .hud{display:flex;justify-content:space-between;margin-top:10px;gap:8px}
  .panel{background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:10px;display:flex;align-items:center;gap:8px}
  .btn{background:linear-gradient(180deg,#1f6bff,#1658d6);border:none;color:white;padding:6px 10px;border-radius:8px;cursor:pointer;font-weight:700}
  .small{font-size:13px;color:var(--muted)}
  .centerNote{position:fixed;left:50%;top:14px;transform:translateX(-50%);pointer-events:none}
  @media (max-width:720px){ #wrap{width:98vw} }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="900" height="600" aria-label="Shadow Stalker game"></canvas>
  <div class="hud">
    <div class="panel">Score: <strong id="score">0</strong></div>
    <div class="panel small">Tap/click nodes — assassinate from behind — arrow/WASD</div>
    <div style="display:flex;gap:8px">
      <button id="restart" class="btn">Restart</button>
      <button id="mute" class="btn">Mute</button>
    </div>
  </div>
</div>
<div class="centerNote" id="centerNote"></div>

<script>
/*
Shadow Stalker — high-fidelity Hunter Assassin–style single-file game.
Differences: original name, procedural art, and unique code — gameplay and mechanics are intentionally similar.
*/

(() => {
  // canvas setup
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: true });
  let W = canvas.width, H = canvas.height;

  // UI elements
  const scoreEl = document.getElementById('score');
  const restartBtn = document.getElementById('restart');
  const muteBtn = document.getElementById('mute');
  const centerNote = document.getElementById('centerNote');

  // Audio
  let audioCtx = null;
  let muted = false;
  function ensureAudio() {
    if (muted) return;
    if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  }
  function sfx(freq=400, dur=0.08, type='sine', vol=0.06) {
    if (muted) return;
    ensureAudio();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
    o.stop(audioCtx.currentTime + dur + 0.02);
  }

  // Game state
  let score = 0;
  let level = 1;
  let gameOver = false;
  let lastTime = performance.now();

  // Grid of nodes (player teleports between nodes)
  const grid = { cols: 5, rows: 4, nodes: [] };
  const margin = 80;

  function buildGrid() {
    grid.nodes.length = 0;
    for (let r = 0; r < grid.rows; r++) {
      for (let c = 0; c < grid.cols; c++) {
        const x = margin + c * ((W - margin*2) / (grid.cols - 1)) + (Math.random()-0.5)*12;
        const y = 120 + r * ((H - 260) / (grid.rows - 1)) + (Math.random()-0.5)*12;
        grid.nodes.push({ x, y, occupied:false });
      }
    }
  }

  // Player: teleports between nodes (classic Hunter Assassin feel)
  const player = { x: W/2, y: H-110, r: 14, targetNode: null, moving: false, moveT:0, from:null, to:null, alive:true };

  // Enemies (guards)
  class Guard {
    constructor(nodeIndex) {
      this.nodeIndex = nodeIndex; // which node to initially occupy
      const n = grid.nodes[nodeIndex];
      this.x = n.x + (Math.random()-0.5)*8;
      this.y = n.y + (Math.random()-0.5)*8;
      this.r = 14;
      this.angle = Math.random()*Math.PI*2;
      this.view = Math.PI*0.52;
      this.viewDist = 160;
      this.patrolCooldown = 0;
      this.dead = false;
      this.flash = 0;
      this.id = Math.random().toString(36).slice(2,8);
    }
    update(dt) {
      if (this.dead) return;
      // slight idle rotation
      this.angle += Math.sin(Date.now()/1200 + this.id.length)*0.002;
      // occasional small step
      this.patrolCooldown -= dt;
      if (this.patrolCooldown <= 0) {
        this.patrolCooldown = 0.8 + Math.random()*2.0;
        // small jitter movement around node
        const n = grid.nodes[this.nodeIndex];
        this.x = n.x + (Math.random()-0.5)*18;
        this.y = n.y + (Math.random()-0.5)*18;
      }
      this.flash = Math.max(0, this.flash - dt);
    }
  }

  let guards = [];

  function spawnGuards(count) {
    guards = [];
    // choose random nodes for guards, ensure not all clustered
    const idxs = [...Array(grid.nodes.length).keys()];
    shuffleArray(idxs);
    for (let i=0;i<count && i<idxs.length;i++){
      guards.push(new Guard(idxs[i]));
    }
  }

  // Helpers
  function shuffleArray(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

  function dist(ax,ay,bx,by){ return Math.hypot(ax-bx, ay-by); }
  function angleBetween(ax,ay,bx,by){ return Math.atan2(by-ay, bx-ax); }
  function normalize(a){ while(a<=-Math.PI) a+=Math.PI*2; while(a>Math.PI) a-=Math.PI*2; return a; }

  // Click / touch to move: choose nearest node to click
  function screenToCanvas(ev){
    const rect = canvas.getBoundingClientRect();
    if (ev.touches && ev.touches[0]) {
      return { x: (ev.touches[0].clientX - rect.left) * (canvas.width/rect.width),
               y: (ev.touches[0].clientY - rect.top) * (canvas.height/rect.height) };
    } else {
      return { x: (ev.clientX - rect.left) * (canvas.width/rect.width),
               y: (ev.clientY - rect.top) * (canvas.height/rect.height) };
    }
  }

  canvas.addEventListener('mousedown', onPointer);
  canvas.addEventListener('touchstart', onPointer, {passive:false});
  function onPointer(e){
    e.preventDefault();
    if (!player.alive) return;
    const p = screenToCanvas(e);
    // choose nearest grid node to pointer
    let best = null, bd=1e9;
    for (const n of grid.nodes) {
      const d = dist(p.x,p.y,n.x,n.y);
      if (d < bd){ bd = d; best = n; }
    }
    if (best) {
      startMoveToNode(best);
    }
  }

  // keyboard movement: arrow/WASD -> choose neighbor node in direction
  window.addEventListener('keydown', (ev) => {
    if (!player.alive) return;
    const k = ev.key.toLowerCase();
    const dir = { x:0,y:0 };
    if (k==='arrowup' || k==='w') dir.y = -1;
    if (k==='arrowdown' || k==='s') dir.y = 1;
    if (k==='arrowleft' || k==='a') dir.x = -1;
    if (k==='arrowright' || k==='d') dir.x = 1;
    if (dir.x===0 && dir.y===0) return;
    // pick node favored by direction relative to player
    let best = null, bestScore=-1e9;
    for (const n of grid.nodes) {
      const vx = n.x - player.x, vy = n.y - player.y;
      const d = Math.hypot(vx,vy);
      if (d < 20) continue; // skip same spot
      const dot = (vx*dir.x + vy*dir.y) / (d+0.0001);
      const score = dot*300 - d*0.6 + (Math.random()*40);
      if (score > bestScore) { bestScore = score; best = n; }
    }
    if (best) startMoveToNode(best);
  });

  function startMoveToNode(node) {
    player.from = { x: player.x, y: player.y };
    player.to = { x: node.x, y: node.y - 6 }; // slight vertical offset for visual
    player.moveT = 0;
    player.moving = true;
    player.targetNode = node;
    sfx(800,0.06,'square',0.07);
  }

  // Assassination logic: if you arrive near a guard and are behind them -> kill
  function attemptAssassinate(guard) {
    if (guard.dead) return false;
    const d = dist(player.x,player.y, guard.x,guard.y);
    if (d > 26) return false;
    // compute relative angle from guard facing to player
    const angToPlayer = angleBetween(guard.x,guard.y, player.x,player.y);
    const rel = normalize(angToPlayer - guard.angle);
    // behind if around PI (±60deg)
    if (Math.abs(Math.PI - Math.abs(rel)) < 1.05) {
      // kill
      guard.dead = true;
      guard.flash = 0.8;
      spawnParticles(guard.x, guard.y, 20);
      score += 120 * Math.min(5, level);
      scoreEl.textContent = score;
      sfx(1400,0.08,'triangle',0.08);
      return true;
    }
    return false;
  }

  // Vision & detection: guard sees player -> lose
  function guardSeesPlayer(guard) {
    if (guard.dead) return false;
    const d = dist(guard.x,guard.y, player.x,player.y);
    if (d > guard.viewDist) return false;
    const a = angleBetween(guard.x,guard.y, player.x,player.y);
    const rel = normalize(a - guard.angle);
    if (Math.abs(rel) > guard.view/2) return false;
    // basic line-of-sight: check if any grid node (cover) is directly between (approx sample along line)
    const steps = 8;
    for (let i=1;i<steps;i++){
      const t = i/steps;
      const x = lerp(guard.x, player.x, t);
      const y = lerp(guard.y, player.y, t);
      // if point is close to any node center, treat as cover blocking (simple approximation)
      for (const n of grid.nodes){
        if (dist(x,y,n.x,n.y) < 16) return false; // blocked by node/cover
      }
    }
    return true;
  }

  function lerp(a,b,t){ return a + (b-a)*(t); }

  // Particles for kills
  const particles = [];
  function spawnParticles(x,y,count=14){
    for (let i=0;i<count;i++){
      particles.push({
        x,y,vx:(Math.random()-0.5)*180, vy:(Math.random()-1.2)*160,
        life:0.6 + Math.random()*0.8, size:2+Math.random()*3
      });
    }
  }

  // Game flow: spawn level
  function spawnLevel(l) {
    buildGrid();
    // number of guards
    const n = Math.min(12, Math.floor(2 + l * 1.25));
    spawnGuards(n);
    player.x = W/2; player.y = H - 110; player.moving=false; player.alive=true;
    gameOver = false;
    centerFlash(`Stage ${l}`);
    sfx(700 + l*30, 0.08, 'sawtooth', 0.08);
  }

  // Draw loop
  function render(dt) {
    ctx.clearRect(0,0,W,H);
    // background gradient
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#071018'); g.addColorStop(1,'#041018');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // subtle top ambient circles
    for (let i=0;i<5;i++){
      const rx = margin + i*(W-2*margin)/4;
      const ry = 60 + Math.sin((Date.now()/1000)+i)*6;
      const gr = ctx.createRadialGradient(rx,ry,0, rx,ry,80);
      gr.addColorStop(0,'rgba(40,80,110,0.03)');
      gr.addColorStop(1,'rgba(10,18,24,0)');
      ctx.fillStyle = gr;
      ctx.fillRect(rx-80,ry-80,160,160);
    }

    // Draw links between nodes (grid lines)
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 2;
    for (const n1 of grid.nodes) {
      for (const n2 of grid.nodes) {
        if (Math.hypot(n1.x-n2.x, n1.y-n2.y) < 160) {
          ctx.beginPath();
          ctx.moveTo(n1.x, n1.y);
          ctx.lineTo(n2.x, n2.y);
          ctx.stroke();
        }
      }
    }

    // Draw nodes (covers)
    for (const n of grid.nodes) {
      // shadow
      ctx.beginPath();
      ctx.ellipse(n.x, n.y+12, 28, 8, 0,0,Math.PI*2);
      ctx.fillStyle = 'rgba(0,0,0,0.28)';
      ctx.fill();
      // node body
      ctx.beginPath();
      roundRect(ctx, n.x - 22, n.y - 12, 44, 22, 8);
      ctx.fillStyle = 'rgba(20,60,70,0.9)';
      ctx.fill();
      // highlight
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      roundRect(ctx, n.x - 22, n.y - 12, 44, 10, 8);
    }

    // Sort draw order by y to get depth
    const drawables = [...guards, player];
    drawables.sort((a,b)=> (a.y||a.pos?.y) - (b.y||b.pos?.y));

    // Draw guards and player
    for (const obj of drawables) {
      if (obj === player) drawPlayer();
      else drawGuard(obj);
    }

    // particles
    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 350 * dt;
      p.life -= dt;
      ctx.globalAlpha = Math.max(0, p.life/1.2);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,220,150,0.95)';
      ctx.fill();
      ctx.globalAlpha = 1;
      if (p.life <= 0) particles.splice(i,1);
    }

    // top-left small panel: level
    ctx.fillStyle = 'rgba(0,0,0,0.28)';
    ctx.fillRect(12,12,140,34);
    ctx.fillStyle = '#cfeff2';
    ctx.font = '600 14px Inter, system-ui';
    ctx.fillText('Level ' + level, 20, 34);
  }

  function drawPlayer() {
    // shadow
    ctx.beginPath();
    ctx.ellipse(player.x, player.y+18, player.r*1.8, player.r*0.5, 0,0,Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.28)'; ctx.fill();

    // movement interpolation if moving
    if (player.moving && player.from && player.to) {
      const t = Math.min(1, player.moveT);
      const fx = lerp(player.from.x, player.to.x, easeOutQuad(t));
      const fy = lerp(player.from.y, player.to.y, easeOutQuad(t));
      drawAgent(fx, fy, player.r, '#12b28a', true);
      // set visible pos for detection checks
      player.x = fx; player.y = fy;
      if (t >= 1) {
        player.moving = false;
        player.from = player.to = null;
        // upon arrival, attempt assassination if near any guard
        for (const g of guards) {
          if (attemptAssassinate(g)) break;
        }
      }
    } else {
      drawAgent(player.x, player.y, player.r, '#12b28a', true);
    }
  }

  function drawAgent(x,y,r,color,isPlayer=false){
    // body cloak
    ctx.save(); ctx.translate(x,y);
    ctx.beginPath();
    ctx.moveTo(-r*1.2, -r*0.5);
    ctx.lineTo(r*1.4, 0);
    ctx.lineTo(-r*1.2, r*0.5);
    ctx.closePath();
    ctx.fillStyle = color; ctx.fill();
    // head
    ctx.beginPath(); ctx.arc(0,0,r*0.65,0,Math.PI*2);
    ctx.fillStyle = '#f0f5f6'; ctx.fill();
    ctx.restore();

    // small movement trail for player
    if (isPlayer && player.moving && player.to) {
      ctx.beginPath();
      ctx.setLineDash([6,10]);
      ctx.strokeStyle = 'rgba(200,240,255,0.14)';
      ctx.moveTo(x,y); ctx.lineTo(player.to.x, player.to.y);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  function drawGuard(g) {
    if (g.dead) {
      // collapsed body
      ctx.save();
      ctx.translate(g.x, g.y);
      ctx.rotate(0.5);
      ctx.fillStyle = '#2e3033';
      ctx.fillRect(-10, -6, 22, 12);
      ctx.restore();
      return;
    }
    // vision cone
    ctx.save();
    ctx.translate(g.x, g.y);
    ctx.rotate(g.angle);
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.arc(0,0, g.viewDist, -g.view/2, g.view/2);
    ctx.closePath();
    ctx.fillStyle = `rgba(255,240,155,${0.06 + (g.flash? 0.18:0)})`;
    ctx.fill();
    ctx.restore();

    // body
    ctx.beginPath(); ctx.arc(g.x, g.y, g.r, 0, Math.PI*2);
    ctx.fillStyle = '#d05b5b'; ctx.fill();
    // head
    ctx.beginPath(); ctx.arc(g.x + Math.cos(g.angle)*4, g.y + Math.sin(g.angle)*4, g.r*0.6, 0, Math.PI*2);
    ctx.fillStyle = '#1f1f1f'; ctx.fill();

    // flash outline if recently saw or killed
    if (g.flash > 0) {
      ctx.beginPath();
      ctx.arc(g.x, g.y, g.r + 6*g.flash, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(255,90,90,${g.flash})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  // Game update loop
  function update(dt) {
    if (gameOver) return;
    // update player move interpolation
    if (player.moving) {
      player.moveT += dt * 3.5; // speed factor (t from 0->1)
    }

    // update guards
    for (const g of guards) {
      g.update(dt);
    }

    // detection checks (guards see player)
    for (const g of guards) {
      if (g.dead) continue;
      if (guardSeesPlayer(g)) {
        g.flash = 0.8;
        triggerLose();
        break;
      }
    }

    // particles update is handled in render dt
    // check level cleared
    const alive = guards.filter(x=>!x.dead).length;
    if (alive === 0) {
      level++;
      spawnLevel(level);
    }
  }

  function triggerLose() {
    if (!player.alive) return;
    player.alive = false;
    gameOver = true;
    sfx(120,0.65,'sine',0.12);
    spawnParticles(player.x, player.y, 36);
    centerFlash('You were spotted! Tap Restart', true);
  }

  // small UI/center messages
  function centerFlash(text, danger=false) {
    centerNote.innerHTML = `<div style="padding:8px 12px;border-radius:8px;background:rgba(0,0,0,0.45);color:${danger? '#ffb6b6':'#cfeff2'};font-weight:700">${text}</div>`;
    setTimeout(()=>centerNote.innerHTML='', 2100);
  }

  // main loop
  function loop(t) {
    const dt = Math.min(0.032, (t - lastTime)/1000);
    lastTime = t;
    update(dt);
    render(dt);
    if (!gameOver) requestAnimationFrame(loop);
    else {
      // final overlay
      ctx.fillStyle = 'rgba(3,5,6,0.6)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#fff'; ctx.font = '700 36px Inter, system-ui'; ctx.textAlign='center';
      ctx.fillText('You were spotted', W/2, H/2 - 8);
      ctx.font = '500 18px Inter, system-ui';
      ctx.fillText('Press Restart to play again', W/2, H/2 + 28);
      ctx.textAlign='start';
    }
  }

  // Utilities
  function easeOutQuad(t){ return 1 - (1-t)*(1-t); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  // Resize handling and devicePixelRatio
  function adjustCanvas() {
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.max(300, Math.round(rect.width));
    const cssH = Math.max(200, Math.round(rect.height));
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    const newW = Math.round(cssW * dpr);
    const newH = Math.round(cssH * dpr);
    if (canvas.width !== newW || canvas.height !== newH) {
      canvas.width = newW; canvas.height = newH;
      W = newW; H = newH;
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
  }
  window.addEventListener('resize', adjustCanvas);

  // restart & mute handlers
  restartBtn.addEventListener('click', () => {
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    startGame();
  });
  muteBtn.addEventListener('click', () => {
    muted = !muted;
    muteBtn.textContent = muted ? 'Unmute' : 'Mute';
    if (muted && audioCtx) { try{ audioCtx.suspend(); }catch(e){} }
    else if (audioCtx && audioCtx.state === 'suspended'){ audioCtx.resume(); }
  });

  // quick tap on enemy to perform kill (convenience)
  canvas.addEventListener('click', (ev) => {
    const p = screenToCanvas(ev);
    for (const g of guards) {
      if (g.dead) continue;
      if (dist(p.x,p.y,g.x,g.y) < 28) {
        // teleport player behind guard and kill if behind
        player.x = g.x - Math.cos(g.angle)*26;
        player.y = g.y - Math.sin(g.angle)*26;
        player.moving=false;
        attemptAssassinate(g);
        break;
      }
    }
  });

  // tick start
  function startGame() {
    adjustCanvas();
    score = 0; level = 1; scoreEl.textContent = score;
    buildGrid();
    spawnLevel(level);
    particles.length = 0;
    lastTime = performance.now();
    requestAnimationFrame(loop);
    centerFlash('Tap/click nodes to move — Assassinate from behind');
  }

  // initial helpers
  function spawnGuards(count){
    spawnGuards = function(){};
    // reuse earlier defined function name collision fix
  }

  // OOPS fix: correct spawnGuards defined earlier used by spawnLevel; re-define properly:
  function spawnGuards(count) {
    guards = [];
    const idxs = [...Array(grid.nodes.length).keys()];
    shuffleArray(idxs);
    for (let i=0;i<count && i<idxs.length;i++) guards.push(new Guard(idxs[i]));
  }

  // Kick off
  adjustCanvas();
  startGame();

})();
</script>
</body>
</html>
